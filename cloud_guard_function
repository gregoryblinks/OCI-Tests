import io, os, json, logging, base64, datetime
import oracledb
import oci

# ---------- ENV ----------
ADW_CONNECT_STRING = os.getenv("ADW_CONNECT_STRING")  # full (description=...) copied from ADW (TLS)
ADW_USER = os.getenv("ADW_USER", "CLOUDGUARD_APP")
ADW_PASSWORD_SECRET_OCID = os.getenv("ADW_PASSWORD_SECRET_OCID")  # Vault secret OCID

# ---------- Helpers ----------

RANK_MAP = {"CRITICAL":4, "MAJOR":3, "HIGH":3, "MINOR":2, "MEDIUM":2, "LOW":1}

def _rank(sev: str, risk: str) -> int:
    s = (sev or "").upper()
    r = (risk or "").upper()
    return RANK_MAP.get(s, RANK_MAP.get(r, 0))

def _parse_ts(s: str):
    if not s: return None
    try:
        # handle both "...Z" and with millis
        s = s.replace("Z", "+00:00")
        return datetime.datetime.fromisoformat(s).replace(tzinfo=None)  # store as UTC TIMESTAMP
    except Exception:
        return None

def flatten_row(ev: dict) -> dict:
    data = ev.get("data", {}) or {}
    addl = data.get("additionalDetails", {}) or {}
    exts = ev.get("extensions", {}) or {}

    severity = (data.get("severity") or "").upper()
    risk = (addl.get("riskLevel") or data.get("riskLevel") or "")

    return {
        "event_time":            _parse_ts(ev.get("eventTime")),
        "event_type":            ev.get("eventType", ""),
        "cloud_events_version":  ev.get("cloudEventsVersion", ""),
        "payload_version":       ev.get("eventTypeVersion", ""),
        "source":                ev.get("source", ""),
        "event_id":              ev.get("eventID", ""),  # PK / de-dupe key

        "tenant_id":             addl.get("tenantId", ""),
        "compartment_id":        data.get("compartmentId", ""),
        "extensions_compartment_id": exts.get("compartmentId", ""),
        "compartment_name":      data.get("compartmentName", ""),
        "region":                addl.get("region", ""),

        "problem_id":            data.get("resourceId", ""),
        "problem_name":          addl.get("problemName") or data.get("resourceName", ""),
        "problem_display_name":  data.get("resourceName", ""),
        "problem_type":          addl.get("problemType", ""),
        "reason":                addl.get("reason", ""),

        "severity":              severity,
        "severity_rank":         _rank(severity, risk),
        "risk_level":            risk,

        "resource_type":         addl.get("resourceType", ""),
        "resource_name":         addl.get("resourceName", ""),
        "resource_id":           addl.get("resourceId", ""),
        "target_id":             addl.get("targetId", ""),
        "lifecycle_state":       addl.get("status", ""),

        "problem_description":   addl.get("problemDescription", ""),
        "recommendation":        addl.get("problemRecommendation", ""),
        "first_detected":        _parse_ts(addl.get("firstDetected")),
        "last_detected":         _parse_ts(addl.get("lastDetected")),

        "labels":                addl.get("labels", ""),
        "additional_details_json": json.dumps(addl, separators=(",", ":"), ensure_ascii=False) if addl else "",
        "raw_event_json":        json.dumps(ev, separators=(",", ":"), ensure_ascii=False) if ev else "",
    }

# Vault secret fetch using Resource Principal
def _get_db_password(signer) -> str:
    sc = oci.secrets.SecretsClient(config={}, signer=signer)
    bundle = sc.get_secret_bundle(ADW_PASSWORD_SECRET_OCID).data
    # secret content is base64-encoded
    content = bundle.secret_bundle_content.content
    return base64.b64decode(content).decode("utf-8")

# Keep a global pool across warm invocations
POOL = None

def _get_pool():
    global POOL
    if POOL:
        return POOL

    # Resource Principal signer (also used by Vault above)
    signer = oci.auth.signers.get_resource_principals_signer()

    if not ADW_CONNECT_STRING:
        raise ValueError("ADW_CONNECT_STRING env var is required (TLS connection descriptor from ADW).")
    if not ADW_PASSWORD_SECRET_OCID:
        raise ValueError("ADW_PASSWORD_SECRET_OCID env var is required (Vault secret OCID).")

    db_password = _get_db_password(signer)

    # Wallet-less TLS: pass the full (description=...) connect descriptor as 'dsn'
    # Ensure ADW is set to allow TLS connections (not mutual TLS) and ACL allows your VCN/NAT.  See docs.
    POOL = oracledb.create_pool(
        user=ADW_USER,
        password=db_password,
        dsn=ADW_CONNECT_STRING,
        min=1, max=4, increment=1
    )
    return POOL

MERGE_SQL = """
MERGE INTO CLOUDGUARD_APP.CLOUDGUARD_FINDINGS t
USING (SELECT :event_id AS event_id FROM dual) s
ON (t.event_id = s.event_id)
WHEN NOT MATCHED THEN INSERT (
  EVENT_TIME, EVENT_TYPE, CLOUD_EVENTS_VERSION, PAYLOAD_VERSION, SOURCE, EVENT_ID,
  TENANT_ID, COMPARTMENT_ID, EXTENSIONS_COMPARTMENT_ID, COMPARTMENT_NAME, REGION,
  PROBLEM_ID, PROBLEM_NAME, PROBLEM_DISPLAY_NAME, PROBLEM_TYPE, REASON,
  SEVERITY, SEVERITY_RANK, RISK_LEVEL,
  RESOURCE_TYPE, RESOURCE_NAME, RESOURCE_ID, TARGET_ID, LIFECYCLE_STATE,
  PROBLEM_DESCRIPTION, RECOMMENDATION,
  FIRST_DETECTED, LAST_DETECTED,
  LABELS, ADDITIONAL_DETAILS_JSON, RAW_EVENT_JSON
) VALUES (
  :event_time, :event_type, :cloud_events_version, :payload_version, :source, :event_id,
  :tenant_id, :compartment_id, :extensions_compartment_id, :compartment_name, :region,
  :problem_id, :problem_name, :problem_display_name, :problem_type, :reason,
  :severity, :severity_rank, :risk_level,
  :resource_type, :resource_name, :resource_id, :target_id, :lifecycle_state,
  :problem_description, :recommendation,
  :first_detected, :last_detected,
  :labels, :additional_details_json, :raw_event_json
)
"""

def handler(ctx, data: io.BytesIO = None):
    try:
        body = data.getvalue().decode("utf-8") if data else "{}"
        payload = json.loads(body) if body else {}
        events = payload if isinstance(payload, list) else [payload]

        rows = [flatten_row(ev) for ev in events]
        pool = _get_pool()
        with pool.acquire() as conn:
            with conn.cursor() as cur:
                cur.executemany(MERGE_SQL, rows)
            conn.commit()

        msg = f"Inserted/Merged {len(rows)} finding(s) into ADW."
        logging.getLogger().info(msg)
        return msg

    except Exception as e:
        logging.getLogger().error("ADW insert error: %s", e, exc_info=True)
        return f"Error: {e}"
