-- User for the pipeline
CREATE USER CLOUDGUARD_APP IDENTIFIED BY "CGADW_test0987//";
GRANT CONNECT, RESOURCE TO CLOUDGUARD_APP;
ALTER USER CLOUDGUARD_APP QUOTA UNLIMITED ON DATA;

-- Findings table (flat + raw JSON)
CREATE TABLE CLOUDGUARD_APP.CLOUDGUARD_FINDINGS (
  EVENT_TIME          TIMESTAMP,
  EVENT_TYPE          VARCHAR2(100),
  CLOUD_EVENTS_VERSION VARCHAR2(20),
  PAYLOAD_VERSION     VARCHAR2(20),
  SOURCE              VARCHAR2(100),
  EVENT_ID            VARCHAR2(200),
  TENANT_ID           VARCHAR2(200),
  COMPARTMENT_ID      VARCHAR2(200),
  EXTENSIONS_COMPARTMENT_ID VARCHAR2(200),
  COMPARTMENT_NAME    VARCHAR2(200),
  REGION              VARCHAR2(50),
  PROBLEM_ID          VARCHAR2(200),
  PROBLEM_NAME        VARCHAR2(200),
  PROBLEM_DISPLAY_NAME VARCHAR2(200),
  PROBLEM_TYPE        VARCHAR2(100),
  REASON              VARCHAR2(200),
  SEVERITY            VARCHAR2(20),
  SEVERITY_RANK       NUMBER,
  RISK_LEVEL          VARCHAR2(20),
  RESOURCE_TYPE       VARCHAR2(50),
  RESOURCE_NAME       VARCHAR2(200),
  RESOURCE_ID         VARCHAR2(200),
  TARGET_ID           VARCHAR2(200),
  LIFECYCLE_STATE     VARCHAR2(30),
  PROBLEM_DESCRIPTION CLOB,
  RECOMMENDATION      CLOB,
  FIRST_DETECTED      TIMESTAMP,
  LAST_DETECTED       TIMESTAMP,
  LABELS              VARCHAR2(4000),
  ADDITIONAL_DETAILS_JSON CLOB,
  RAW_EVENT_JSON      CLOB,
  INSERTED_AT         TIMESTAMP DEFAULT SYSTIMESTAMP,
  CONSTRAINT CG_FINDINGS_PK PRIMARY KEY (EVENT_ID)
);

CREATE INDEX CG_IDX_EVTIME ON CLOUDGUARD_APP.CLOUDGUARD_FINDINGS(EVENT_TIME);
CREATE INDEX CG_IDX_SEV    ON CLOUDGUARD_APP.CLOUDGUARD_FINDINGS(SEVERITY_RANK);
CREATE INDEX CG_IDX_COMP   ON CLOUDGUARD_APP.CLOUDGUARD_FINDINGS(COMPARTMENT_NAME);

SELECT COUNT(*) FROM CLOUDGUARD_APP.CLOUDGUARD_FINDINGS;
SELECT EVENT_TIME, SEVERITY, COMPARTMENT_NAME, PROBLEM_NAME
FROM CLOUDGUARD_APP.CLOUDGUARD_FINDINGS
ORDER BY INSERTED_AT DESC FETCH FIRST 10 ROWS ONLY;

-- Fill SEVERITY from RISK_LEVEL where it's NULL
UPDATE CLOUDGUARD_APP.CLOUDGUARD_FINDINGS
   SET SEVERITY = UPPER(RISK_LEVEL)
 WHERE SEVERITY IS NULL;

-- Ensure SEVERITY_RANK matches the final value
UPDATE CLOUDGUARD_APP.CLOUDGUARD_FINDINGS
   SET SEVERITY_RANK =
       CASE
         WHEN UPPER(COALESCE(SEVERITY, RISK_LEVEL)) = 'CRITICAL' THEN 4
         WHEN UPPER(COALESCE(SEVERITY, RISK_LEVEL)) IN ('HIGH','MAJOR') THEN 3
         WHEN UPPER(COALESCE(SEVERITY, RISK_LEVEL)) IN ('MEDIUM','MINOR') THEN 2
         WHEN UPPER(COALESCE(SEVERITY, RISK_LEVEL)) = 'LOW' THEN 1
         ELSE 0
       END
 WHERE SEVERITY_RANK IS NULL OR SEVERITY IS NULL;



Canonicalize the event types (single source for the rest)

CREATE OR REPLACE VIEW CLOUDGUARD_APP.CG_EVENTS_CANON AS
SELECT
  event_time,
  UPPER(event_type) AS event_type_u,
  CASE
    WHEN UPPER(event_type) = 'COM.ORACLECLOUD.CLOUDGUARD.PROBLEMDETECTED'   THEN 'DETECTED'
    WHEN UPPER(event_type) = 'COM.ORACLECLOUD.CLOUDGUARD.PROBLEMREMEDIATED' THEN 'REMEDIATED'
    WHEN UPPER(event_type) = 'COM.ORACLECLOUD.CLOUDGUARD.PROBLEMDISMISSED'  THEN 'DISMISSED'
    WHEN UPPER(event_type) = 'COM.ORACLECLOUD.CLOUDGUARD.SIGHTINGDETECTED'  THEN 'SIGHTING'
    ELSE 'OTHER'
  END AS event_kind,
  problem_id,
  lifecycle_state,
  risk_level,
  severity,
  severity_rank,
  compartment_name,
  region
FROM CLOUDGUARD_APP.CLOUDGUARD_FINDINGS;

First time the problem was detected OPEN
CREATE OR REPLACE VIEW CLOUDGUARD_APP.CG_DETECTED_OPEN AS
SELECT
  problem_id,
  MIN(event_time) AS first_detected_time,
  MAX(risk_level)       KEEP (DENSE_RANK FIRST ORDER BY event_time) AS risk_at_detection,
  MAX(severity)         KEEP (DENSE_RANK FIRST ORDER BY event_time) AS severity_at_detection,
  MAX(severity_rank)    KEEP (DENSE_RANK FIRST ORDER BY event_time) AS severity_rank_at_detection,
  MAX(compartment_name) KEEP (DENSE_RANK FIRST ORDER BY event_time) AS compartment_name,
  MAX(region)           KEEP (DENSE_RANK FIRST ORDER BY event_time) AS region
FROM CLOUDGUARD_APP.CG_EVENTS_CANON
WHERE event_kind = 'DETECTED'
  AND UPPER(lifecycle_state) = 'OPEN'
GROUP BY problem_id;

Earliest explicit remediation and dismissal for that problem
CREATE OR REPLACE VIEW CLOUDGUARD_APP.CG_REMEDIATED_BY_EVENT AS
SELECT problem_id, MIN(event_time) AS remediated_time
FROM   CLOUDGUARD_APP.CG_EVENTS_CANON
WHERE  event_kind = 'REMEDIATED'
GROUP  BY problem_id;

CREATE OR REPLACE VIEW CLOUDGUARD_APP.CG_DISMISSED_BY_EVENT AS
SELECT problem_id, MIN(event_time) AS dismissed_time
FROM   CLOUDGUARD_APP.CG_EVENTS_CANON
WHERE  event_kind = 'DISMISSED'
GROUP  BY problem_id;

(Optional) Sightings context (earliest sighting)
CREATE OR REPLACE VIEW CLOUDGUARD_APP.CG_SIGHTING_FIRST AS
SELECT problem_id, MIN(event_time) AS first_sighting_time
FROM   CLOUDGUARD_APP.CG_EVENTS_CANON
WHERE  event_kind = 'SIGHTING'
GROUP  BY problem_id;

Detection â†’ Remediation/Dismissal alignment (with timings)
CREATE OR REPLACE VIEW CLOUDGUARD_APP.CG_DETECT_VS_CLOSE AS
SELECT
  d.problem_id,
  d.first_detected_time,
  r.remediated_time,
  x.dismissed_time,
  -- first close event after detection (if any)
  CASE
    WHEN r.remediated_time IS NOT NULL AND x.dismissed_time IS NOT NULL
      THEN LEAST(r.remediated_time, x.dismissed_time)
    WHEN r.remediated_time IS NOT NULL THEN r.remediated_time
    WHEN x.dismissed_time  IS NOT NULL THEN x.dismissed_time
    ELSE NULL
  END AS first_close_time,
  CASE
    WHEN r.remediated_time IS NOT NULL AND (x.dismissed_time IS NULL OR r.remediated_time <= x.dismissed_time)
         AND r.remediated_time >= d.first_detected_time
      THEN 'REMEDIATED'
    WHEN x.dismissed_time IS NOT NULL AND (r.remediated_time IS NULL OR x.dismissed_time < r.remediated_time)
         AND x.dismissed_time >= d.first_detected_time
      THEN 'DISMISSED'
    ELSE NULL
  END AS closure_type,
  CASE
    WHEN r.remediated_time IS NOT NULL AND r.remediated_time >= d.first_detected_time THEN 'YES' ELSE 'NO'
  END AS remediated_explicit,
  CASE
    WHEN (r.remediated_time IS NOT NULL AND r.remediated_time >= d.first_detected_time)
      OR (x.dismissed_time  IS NOT NULL AND x.dismissed_time  >= d.first_detected_time)
      THEN 'YES' ELSE 'NO'
  END AS closed_either,  -- either remediated OR dismissed
  CASE
    WHEN r.remediated_time IS NOT NULL THEN ROUND( (CAST(r.remediated_time AS DATE) - CAST(d.first_detected_time AS DATE)), 4 )
  END AS ttr_days,  -- time to remediate (explicit)
  CASE
    WHEN x.dismissed_time IS NOT NULL THEN ROUND( (CAST(x.dismissed_time AS DATE) - CAST(d.first_detected_time AS DATE)), 4 )
  END AS ttd_days,  -- time to dismiss
  d.risk_at_detection,
  d.severity_at_detection,
  d.severity_rank_at_detection,
  d.compartment_name,
  d.region
FROM CLOUDGUARD_APP.CG_DETECTED_OPEN d
LEFT JOIN CLOUDGUARD_APP.CG_REMEDIATED_BY_EVENT r ON r.problem_id = d.problem_id
LEFT JOIN CLOUDGUARD_APP.CG_DISMISSED_BY_EVENT  x ON x.problem_id = d.problem_id;

(Optional) Reopens after a close (quality signal)
CREATE OR REPLACE VIEW CLOUDGUARD_APP.CG_DETECT_VS_CLOSE_REOPEN AS
SELECT c.*,
       CASE
         WHEN c.first_close_time IS NOT NULL AND EXISTS (
           SELECT 1
           FROM CLOUDGUARD_APP.CG_EVENTS_CANON e
           WHERE e.problem_id = c.problem_id
             AND e.event_time > c.first_close_time
             AND UPPER(e.lifecycle_state) = 'OPEN'
         ) THEN 'YES' ELSE 'NO'
       END AS reopened_after_close
FROM CLOUDGUARD_APP.CG_DETECT_VS_CLOSE c;

Daily cohort stats (detected vs closed types)
CREATE OR REPLACE VIEW CLOUDGUARD_APP.CG_COHORT_DAILY AS
SELECT
  TRUNC(first_detected_time) AS day,
  COUNT(*)                   AS problems_detected,
  SUM(CASE WHEN remediated_explicit = 'YES' THEN 1 ELSE 0 END) AS remediated_explicit_cnt,
  SUM(CASE WHEN closure_type = 'DISMISSED'   THEN 1 ELSE 0 END) AS dismissed_cnt,
  SUM(CASE WHEN closed_either = 'YES'        THEN 1 ELSE 0 END) AS closed_either_cnt
FROM CLOUDGUARD_APP.CG_DETECT_VS_CLOSE
GROUP BY TRUNC(first_detected_time);

100 * (
  SUM(CASE WHEN "REMEDIATED_EXPLICIT" = 'YES' THEN 1 ELSE 0 END)
  / NULLIF(COUNT("PROBLEM_ID"), 0)
)

100 * (
  SUM(CASE WHEN "CLOSURE_TYPE" = 'DISMISSED' THEN 1 ELSE 0 END)
  / NULLIF(COUNT("PROBLEM_ID"), 0)
)

100 * (
  SUM(CASE WHEN "CLOSED_EITHER" = 'YES' THEN 1 ELSE 0 END)
  / NULLIF(COUNT("PROBLEM_ID"), 0)
)


SELECT problem_id, first_detected_time, remediated_time, dismissed_time
FROM   CLOUDGUARD_APP.CG_DETECT_VS_CLOSE
WHERE  remediated_time < first_detected_time
   OR  dismissed_time  < first_detected_time
FETCH FIRST 50 ROWS ONLY;


CREATE OR REPLACE VIEW CLOUDGUARD_APP.CG_DETECT_VS_CLOSE AS
WITH close_events AS (
  SELECT e.problem_id, e.event_kind, e.event_time
  FROM   CLOUDGUARD_APP.CG_EVENTS_CANON e
  WHERE  e.event_kind IN ('REMEDIATED','DISMISSED')
),
agg AS (
  SELECT
    d.problem_id,
    d.first_detected_time,
    /* only close events on/after first detection */
    MIN(CASE WHEN ce.event_kind = 'REMEDIATED' THEN ce.event_time END) AS remediated_time,
    MIN(CASE WHEN ce.event_kind = 'DISMISSED'  THEN ce.event_time END) AS dismissed_time,
    /* carry context */
    d.risk_at_detection,
    d.severity_at_detection,
    d.severity_rank_at_detection,
    d.compartment_name,
    d.region
  FROM CLOUDGUARD_APP.CG_DETECTED_OPEN d
  LEFT JOIN close_events ce
    ON ce.problem_id = d.problem_id
   AND ce.event_time >= d.first_detected_time
  GROUP BY
    d.problem_id,
    d.first_detected_time,
    d.risk_at_detection,
    d.severity_at_detection,
    d.severity_rank_at_detection,
    d.compartment_name,
    d.region
)
SELECT
  a.problem_id,
  a.first_detected_time,
  a.remediated_time,
  a.dismissed_time,
  /* first close = earliest of the two (if any) */
  CASE
    WHEN a.remediated_time IS NULL AND a.dismissed_time IS NULL THEN NULL
    ELSE LEAST(
           NVL(a.remediated_time, TIMESTAMP '9999-12-31 00:00:00'),
           NVL(a.dismissed_time,  TIMESTAMP '9999-12-31 00:00:00')
         )
  END AS first_close_time,
  /* closure type decided by which is earliest */
  CASE
    WHEN a.remediated_time IS NOT NULL
     AND (a.dismissed_time IS NULL OR a.remediated_time <= a.dismissed_time)
      THEN 'REMEDIATED'
    WHEN a.dismissed_time  IS NOT NULL
      THEN 'DISMISSED'
    ELSE NULL
  END AS closure_type,
  /* flags */
  CASE WHEN a.remediated_time IS NOT NULL THEN 'YES' ELSE 'NO' END AS remediated_explicit,
  CASE WHEN a.remediated_time IS NOT NULL OR a.dismissed_time IS NOT NULL THEN 'YES' ELSE 'NO' END AS closed_either,
  /* durations (days) */
  CASE WHEN a.remediated_time IS NOT NULL
       THEN ROUND(CAST(a.remediated_time AS DATE) - CAST(a.first_detected_time AS DATE), 4) END AS ttr_days,
  CASE WHEN a.dismissed_time IS NOT NULL
       THEN ROUND(CAST(a.dismissed_time  AS DATE) - CAST(a.first_detected_time AS DATE), 4) END AS ttd_days,
  /* context */
  a.risk_at_detection,
  a.severity_at_detection,
  a.severity_rank_at_detection,
  a.compartment_name,
  a.region
FROM agg a;






SELECT COUNT(*) bad_rows
FROM   CLOUDGUARD_APP.CG_DETECT_VS_CLOSE
WHERE  remediated_time < first_detected_time
   OR  dismissed_time  < first_detected_time;


-- Distinct problem names that were ever classified as CRITICAL
SELECT DISTINCT problem_name
FROM   CLOUDGUARD_APP.CLOUDGUARD_FINDINGS
WHERE  UPPER(COALESCE(severity, risk_level)) = 'CRITICAL';



CREATE OR REPLACE VIEW CLOUDGUARD_APP.CG_COHORT_DAILY_SEV AS
WITH base AS (
  SELECT
    TRUNC(first_detected_time)                                       AS day,
    UPPER(NVL(severity_at_detection, risk_at_detection))             AS sev,
    CASE WHEN remediated_time IS NOT NULL THEN 1 ELSE 0 END          AS rem_flg
  FROM CLOUDGUARD_APP.CG_DETECT_VS_CLOSE
),
agg AS (
  SELECT
    day,
    COUNT(*)                                                         AS detected_total,

    /* detected by severity */
    SUM(CASE WHEN sev = 'CRITICAL'                THEN 1 ELSE 0 END) AS detected_critical,
    SUM(CASE WHEN sev IN ('HIGH','MAJOR')         THEN 1 ELSE 0 END) AS detected_high,
    SUM(CASE WHEN sev IN ('MEDIUM','MODERATE')    THEN 1 ELSE 0 END) AS detected_medium,
    SUM(CASE WHEN sev = 'LOW'                     THEN 1 ELSE 0 END) AS detected_low,
    SUM(CASE WHEN sev = 'MINOR'                   THEN 1 ELSE 0 END) AS detected_minor,

    /* remediated (explicit problemremediated) totals and by severity */
    SUM(rem_flg)                                                     AS remediated_total,
    SUM(CASE WHEN sev = 'CRITICAL'                THEN rem_flg ELSE 0 END) AS remediated_critical,
    SUM(CASE WHEN sev IN ('HIGH','MAJOR')         THEN rem_flg ELSE 0 END) AS remediated_high,
    SUM(CASE WHEN sev IN ('MEDIUM','MODERATE')    THEN rem_flg ELSE 0 END) AS remediated_medium,
    SUM(CASE WHEN sev = 'LOW'                     THEN rem_flg ELSE 0 END) AS remediated_low,
    SUM(CASE WHEN sev = 'MINOR'                   THEN rem_flg ELSE 0 END) AS remediated_minor
  FROM base
  GROUP BY day
)
SELECT
  a.*,

  /* overall remediation rate */
  ROUND(a.remediated_total / NULLIF(a.detected_total,0), 4)                AS rate_total,

  /* remediation rate by severity */
  ROUND(a.remediated_critical / NULLIF(a.detected_critical,0), 4)          AS rate_critical,
  ROUND(a.remediated_high     / NULLIF(a.detected_high,0), 4)              AS rate_high,
  ROUND(a.remediated_medium   / NULLIF(a.detected_medium,0), 4)            AS rate_medium,
  ROUND(a.remediated_low      / NULLIF(a.detected_low,0), 4)               AS rate_low,
  ROUND(a.remediated_minor    / NULLIF(a.detected_minor,0), 4)             AS rate_minor
FROM agg a;


Top problem names with the lowest explicit remediation rate (require at least 5 detections to avoid noise):
-- Top problem names with low remediation rate
WITH cohort AS (
  SELECT
    c.problem_id,
    c.first_detected_time,
    c.remediated_time,
    c.dismissed_time,
    c.closure_type,
    /* earliest non-null name at/after detection for this problem_id */
    (SELECT MAX(f.problem_name) KEEP (
       DENSE_RANK FIRST ORDER BY
         CASE WHEN f.problem_name IS NULL
              THEN TIMESTAMP '9999-12-31 00:00:00' ELSE f.event_time END)
     FROM CLOUDGUARD_APP.CLOUDGUARD_FINDINGS f
     WHERE f.problem_id = c.problem_id
       AND f.event_time >= c.first_detected_time) AS problem_name
  FROM CLOUDGUARD_APP.CG_DETECT_VS_CLOSE c
)
SELECT
  problem_name,
  COUNT(*) AS detected,
  SUM(CASE WHEN remediated_time IS NOT NULL THEN 1 ELSE 0 END) AS remediated,
  SUM(CASE WHEN closure_type = 'DISMISSED' THEN 1 ELSE 0 END) AS dismissed,
  SUM(CASE WHEN remediated_time IS NULL AND NVL(closure_type,'') <> 'DISMISSED' THEN 1 ELSE 0 END) AS still_open,
  ROUND( SUM(CASE WHEN remediated_time IS NOT NULL THEN 1 ELSE 0 END) / NULLIF(COUNT(*),0), 4) AS remediation_rate,
  ROUND( SUM(CASE WHEN closure_type = 'DISMISSED' THEN 1 ELSE 0 END) / NULLIF(COUNT(*),0), 4) AS dismissal_rate
FROM cohort
GROUP BY problem_name
HAVING COUNT(*) >= 5
ORDER BY remediation_rate ASC, detected DESC
FETCH FIRST 20 ROWS ONLY;


Interpretation
1.  remediation_rate low â†’ these problem names are the ones â€œmostly not remediatedâ€.
2.  Check dismissal_rate vs still_open to see whether theyâ€™re being dismissed or just lingering open.


2) Why? (diagnose a specific problem name)
ðŸ‘‰ Replace :pname with the problem name you want to analyze.

2A. Outcome split (remediated vs dismissed vs still open)
WITH cohort AS (
  SELECT c.*
  FROM   CLOUDGUARD_APP.CG_DETECT_VS_CLOSE c
  WHERE EXISTS (
    SELECT 1
    FROM   CLOUDGUARD_APP.CLOUDGUARD_FINDINGS f
    WHERE  f.problem_id = c.problem_id
      AND  f.event_time >= c.first_detected_time
      AND  f.problem_name = :pname
  )
)
SELECT 'REMEDIATED' AS outcome, COUNT(*) AS cnt
FROM   cohort
WHERE  remediated_time IS NOT NULL
UNION ALL
SELECT 'DISMISSED', COUNT(*)
FROM   cohort
WHERE  closure_type = 'DISMISSED'
UNION ALL
SELECT 'STILL_OPEN', COUNT(*)
FROM   cohort
WHERE  remediated_time IS NULL AND NVL(closure_type,'') <> 'DISMISSED';


2B) By severity/risk at detection (non-remediated only)
WITH cohort AS (
  SELECT c.*
  FROM   CLOUDGUARD_APP.CG_DETECT_VS_CLOSE c
  WHERE EXISTS (
    SELECT 1 FROM CLOUDGUARD_APP.CLOUDGUARD_FINDINGS f
    WHERE  f.problem_id = c.problem_id
      AND  f.event_time >= c.first_detected_time
      AND  f.problem_name = :pname
  )
)
SELECT
  UPPER(NVL(severity_at_detection, risk_at_detection)) AS severity_bucket,
  COUNT(*) AS detected,
  SUM(CASE WHEN remediated_time IS NULL AND NVL(closure_type,'') <> 'DISMISSED' THEN 1 ELSE 0 END) AS still_open,
  SUM(CASE WHEN closure_type = 'DISMISSED' THEN 1 ELSE 0 END) AS dismissed,
  ROUND(
    SUM(CASE WHEN remediated_time IS NOT NULL THEN 1 END)
    / NULLIF(COUNT(*),0), 4
  ) AS remediation_rate
FROM cohort
GROUP BY UPPER(NVL(severity_at_detection, risk_at_detection))
ORDER BY remediation_rate ASC, detected DESC;


2C) Top compartments where itâ€™s not remediated
WITH cohort AS (
  SELECT c.*
  FROM   CLOUDGUARD_APP.CG_DETECT_VS_CLOSE c
  WHERE EXISTS (
    SELECT 1 FROM CLOUDGUARD_APP.CLOUDGUARD_FINDINGS f
    WHERE  f.problem_id = c.problem_id
      AND  f.event_time >= c.first_detected_time
      AND  f.problem_name = :pname
  )
)
SELECT
  compartment_name,
  COUNT(*) AS detected,
  SUM(CASE WHEN remediated_time IS NOT NULL THEN 1 ELSE 0 END) AS remediated,
  SUM(CASE WHEN closure_type = 'DISMISSED' THEN 1 ELSE 0 END) AS dismissed,
  SUM(CASE WHEN remediated_time IS NULL AND NVL(closure_type,'') <> 'DISMISSED' THEN 1 ELSE 0 END) AS still_open,
  ROUND(
    SUM(CASE WHEN remediated_time IS NOT NULL THEN 1 END)
    / NULLIF(COUNT(*),0), 4
  ) AS remediation_rate
FROM cohort
GROUP BY compartment_name
HAVING COUNT(*) >= 3
ORDER BY remediation_rate ASC, detected DESC
FETCH FIRST 10 ROWS ONLY;

2D) Top resource types where itâ€™s not remediated
WITH cohort AS (
  SELECT
    c.*,
    /* earliest non-null resource_type after detection */
    (SELECT MAX(f.resource_type) KEEP (
       DENSE_RANK FIRST ORDER BY
         CASE WHEN f.resource_type IS NULL
              THEN TIMESTAMP '9999-12-31 00:00:00' ELSE f.event_time END)
     FROM CLOUDGUARD_APP.CLOUDGUARD_FINDINGS f
     WHERE f.problem_id = c.problem_id
       AND f.event_time >= c.first_detected_time) AS resource_type_at_detection
  FROM CLOUDGUARD_APP.CG_DETECT_VS_CLOSE c
  WHERE EXISTS (
    SELECT 1 FROM CLOUDGUARD_APP.CLOUDGUARD_FINDINGS f
    WHERE  f.problem_id = c.problem_id
      AND  f.event_time >= c.first_detected_time
      AND  f.problem_name = :pname
  )
)
SELECT
  resource_type_at_detection AS resource_type,
  COUNT(*) AS detected,
  SUM(CASE WHEN remediated_time IS NOT NULL THEN 1 ELSE 0 END) AS remediated,
  SUM(CASE WHEN closure_type = 'DISMISSED' THEN 1 ELSE 0 END) AS dismissed,
  SUM(CASE WHEN remediated_time IS NULL AND NVL(closure_type,'') <> 'DISMISSED' THEN 1 ELSE 0 END) AS still_open,
  ROUND(
    SUM(CASE WHEN remediated_time IS NOT NULL THEN 1 END)
    / NULLIF(COUNT(*),0), 4
  ) AS remediation_rate
FROM cohort
GROUP BY resource_type_at_detection
HAVING COUNT(*) >= 3
ORDER BY remediation_rate ASC, detected DESC
FETCH FIRST 10 ROWS ONLY;


3) One query to rank â€œnon-remediatedâ€ drivers across all problems
This ranks the combinations of (problem_name, severity_bucket, compartment) where remediation is lowest (and volume â‰¥ 5):

WITH cohort AS (
  SELECT
    c.problem_id,
    c.first_detected_time,
    c.remediated_time,
    c.closure_type,
    UPPER(NVL(c.severity_at_detection, c.risk_at_detection)) AS severity_bucket,
    c.compartment_name,
    (SELECT MAX(f.problem_name) KEEP (
       DENSE_RANK FIRST ORDER BY
         CASE WHEN f.problem_name IS NULL
              THEN TIMESTAMP '9999-12-31 00:00:00' ELSE f.event_time END)
     FROM CLOUDGUARD_APP.CLOUDGUARD_FINDINGS f
     WHERE f.problem_id = c.problem_id
       AND f.event_time >= c.first_detected_time) AS problem_name
  FROM CLOUDGUARD_APP.CG_DETECT_VS_CLOSE c
)
SELECT
  problem_name,
  severity_bucket,
  compartment_name,
  COUNT(*) AS detected,
  SUM(CASE WHEN remediated_time IS NOT NULL THEN 1 ELSE 0 END) AS remediated,
  SUM(CASE WHEN closure_type = 'DISMISSED' THEN 1 ELSE 0 END) AS dismissed,
  SUM(CASE WHEN remediated_time IS NULL AND NVL(closure_type,'') <> 'DISMISSED' THEN 1 ELSE 0 END) AS still_open,
  ROUND( SUM(CASE WHEN remediated_time IS NOT NULL THEN 1 ELSE 0 END) / NULLIF(COUNT(*),0), 4) AS remediation_rate
FROM cohort
GROUP BY problem_name, severity_bucket, compartment_name
HAVING COUNT(*) >= 5
ORDER BY remediation_rate ASC, detected DESC
FETCH FIRST 20 ROWS ONLY;

Use this to answer â€œwhyâ€:
Look at the lowest-rate rowsâ€”do they cluster in certain compartments, risks, or resource types? Thatâ€™s your remediation bottleneck.

One helper view (copyâ€“paste in ADW)
  This wraps your fixed cohort view and adds:
  PROBLEM_NAME (at/after first detection),
  RESOURCE_TYPE (at/after first detection),
  SEVERITY_BUCKET (uses SEVERITY_AT_DETECTION fallback RISK_AT_DETECTION).

CREATE OR REPLACE VIEW CLOUDGUARD_APP.CG_DETECT_VS_CLOSE_NAMED AS
SELECT
  c.problem_id,
  c.first_detected_time,
  c.remediated_time,
  c.dismissed_time,
  c.first_close_time,
  c.closure_type,
  c.remediated_explicit,
  c.closed_either,
  c.ttr_days,
  c.ttd_days,
  c.risk_at_detection,
  c.severity_at_detection,
  c.severity_rank_at_detection,
  c.compartment_name,
  c.region,
  /* derived */
  UPPER(NVL(c.severity_at_detection, c.risk_at_detection)) AS severity_bucket,

  /* earliest non-null name after detection */
  (SELECT MAX(f.problem_name) KEEP (
     DENSE_RANK FIRST ORDER BY
       CASE WHEN f.problem_name IS NULL
            THEN TIMESTAMP '9999-12-31 00:00:00' ELSE f.event_time END)
   FROM CLOUDGUARD_APP.CLOUDGUARD_FINDINGS f
   WHERE f.problem_id = c.problem_id
     AND f.event_time >= c.first_detected_time) AS problem_name,

  /* earliest non-null resource_type after detection */
  (SELECT MAX(f.resource_type) KEEP (
     DENSE_RANK FIRST ORDER BY
       CASE WHEN f.resource_type IS NULL
            THEN TIMESTAMP '9999-12-31 00:00:00' ELSE f.event_time END)
   FROM CLOUDGUARD_APP.CLOUDGUARD_FINDINGS f
   WHERE f.problem_id = c.problem_id
     AND f.event_time >= c.first_detected_time) AS resource_type

FROM CLOUDGUARD_APP.CG_DETECT_VS_CLOSE c;


