-- User for the pipeline
CREATE USER CLOUDGUARD_APP IDENTIFIED BY "CGADW_test0987//";
GRANT CONNECT, RESOURCE TO CLOUDGUARD_APP;
ALTER USER CLOUDGUARD_APP QUOTA UNLIMITED ON DATA;

-- Findings table (flat + raw JSON)
CREATE TABLE CLOUDGUARD_APP.CLOUDGUARD_FINDINGS (
  EVENT_TIME          TIMESTAMP,
  EVENT_TYPE          VARCHAR2(100),
  CLOUD_EVENTS_VERSION VARCHAR2(20),
  PAYLOAD_VERSION     VARCHAR2(20),
  SOURCE              VARCHAR2(100),
  EVENT_ID            VARCHAR2(200),
  TENANT_ID           VARCHAR2(200),
  COMPARTMENT_ID      VARCHAR2(200),
  EXTENSIONS_COMPARTMENT_ID VARCHAR2(200),
  COMPARTMENT_NAME    VARCHAR2(200),
  REGION              VARCHAR2(50),
  PROBLEM_ID          VARCHAR2(200),
  PROBLEM_NAME        VARCHAR2(200),
  PROBLEM_DISPLAY_NAME VARCHAR2(200),
  PROBLEM_TYPE        VARCHAR2(100),
  REASON              VARCHAR2(200),
  SEVERITY            VARCHAR2(20),
  SEVERITY_RANK       NUMBER,
  RISK_LEVEL          VARCHAR2(20),
  RESOURCE_TYPE       VARCHAR2(50),
  RESOURCE_NAME       VARCHAR2(200),
  RESOURCE_ID         VARCHAR2(200),
  TARGET_ID           VARCHAR2(200),
  LIFECYCLE_STATE     VARCHAR2(30),
  PROBLEM_DESCRIPTION CLOB,
  RECOMMENDATION      CLOB,
  FIRST_DETECTED      TIMESTAMP,
  LAST_DETECTED       TIMESTAMP,
  LABELS              VARCHAR2(4000),
  ADDITIONAL_DETAILS_JSON CLOB,
  RAW_EVENT_JSON      CLOB,
  INSERTED_AT         TIMESTAMP DEFAULT SYSTIMESTAMP,
  CONSTRAINT CG_FINDINGS_PK PRIMARY KEY (EVENT_ID)
);

CREATE INDEX CG_IDX_EVTIME ON CLOUDGUARD_APP.CLOUDGUARD_FINDINGS(EVENT_TIME);
CREATE INDEX CG_IDX_SEV    ON CLOUDGUARD_APP.CLOUDGUARD_FINDINGS(SEVERITY_RANK);
CREATE INDEX CG_IDX_COMP   ON CLOUDGUARD_APP.CLOUDGUARD_FINDINGS(COMPARTMENT_NAME);

SELECT COUNT(*) FROM CLOUDGUARD_APP.CLOUDGUARD_FINDINGS;
SELECT EVENT_TIME, SEVERITY, COMPARTMENT_NAME, PROBLEM_NAME
FROM CLOUDGUARD_APP.CLOUDGUARD_FINDINGS
ORDER BY INSERTED_AT DESC FETCH FIRST 10 ROWS ONLY;

-- Fill SEVERITY from RISK_LEVEL where it's NULL
UPDATE CLOUDGUARD_APP.CLOUDGUARD_FINDINGS
   SET SEVERITY = UPPER(RISK_LEVEL)
 WHERE SEVERITY IS NULL;

-- Ensure SEVERITY_RANK matches the final value
UPDATE CLOUDGUARD_APP.CLOUDGUARD_FINDINGS
   SET SEVERITY_RANK =
       CASE
         WHEN UPPER(COALESCE(SEVERITY, RISK_LEVEL)) = 'CRITICAL' THEN 4
         WHEN UPPER(COALESCE(SEVERITY, RISK_LEVEL)) IN ('HIGH','MAJOR') THEN 3
         WHEN UPPER(COALESCE(SEVERITY, RISK_LEVEL)) IN ('MEDIUM','MINOR') THEN 2
         WHEN UPPER(COALESCE(SEVERITY, RISK_LEVEL)) = 'LOW' THEN 1
         ELSE 0
       END
 WHERE SEVERITY_RANK IS NULL OR SEVERITY IS NULL;



Canonicalize the event types (single source for the rest)

CREATE OR REPLACE VIEW CLOUDGUARD_APP.CG_EVENTS_CANON AS
SELECT
  event_time,
  UPPER(event_type) AS event_type_u,
  CASE
    WHEN UPPER(event_type) = 'COM.ORACLECLOUD.CLOUDGUARD.PROBLEMDETECTED'   THEN 'DETECTED'
    WHEN UPPER(event_type) = 'COM.ORACLECLOUD.CLOUDGUARD.PROBLEMREMEDIATED' THEN 'REMEDIATED'
    WHEN UPPER(event_type) = 'COM.ORACLECLOUD.CLOUDGUARD.PROBLEMDISMISSED'  THEN 'DISMISSED'
    WHEN UPPER(event_type) = 'COM.ORACLECLOUD.CLOUDGUARD.SIGHTINGDETECTED'  THEN 'SIGHTING'
    ELSE 'OTHER'
  END AS event_kind,
  problem_id,
  lifecycle_state,
  risk_level,
  severity,
  severity_rank,
  compartment_name,
  region
FROM CLOUDGUARD_APP.CLOUDGUARD_FINDINGS;

First time the problem was detected OPEN
CREATE OR REPLACE VIEW CLOUDGUARD_APP.CG_DETECTED_OPEN AS
SELECT
  problem_id,
  MIN(event_time) AS first_detected_time,
  MAX(risk_level)       KEEP (DENSE_RANK FIRST ORDER BY event_time) AS risk_at_detection,
  MAX(severity)         KEEP (DENSE_RANK FIRST ORDER BY event_time) AS severity_at_detection,
  MAX(severity_rank)    KEEP (DENSE_RANK FIRST ORDER BY event_time) AS severity_rank_at_detection,
  MAX(compartment_name) KEEP (DENSE_RANK FIRST ORDER BY event_time) AS compartment_name,
  MAX(region)           KEEP (DENSE_RANK FIRST ORDER BY event_time) AS region
FROM CLOUDGUARD_APP.CG_EVENTS_CANON
WHERE event_kind = 'DETECTED'
  AND UPPER(lifecycle_state) = 'OPEN'
GROUP BY problem_id;

Earliest explicit remediation and dismissal for that problem
CREATE OR REPLACE VIEW CLOUDGUARD_APP.CG_REMEDIATED_BY_EVENT AS
SELECT problem_id, MIN(event_time) AS remediated_time
FROM   CLOUDGUARD_APP.CG_EVENTS_CANON
WHERE  event_kind = 'REMEDIATED'
GROUP  BY problem_id;

CREATE OR REPLACE VIEW CLOUDGUARD_APP.CG_DISMISSED_BY_EVENT AS
SELECT problem_id, MIN(event_time) AS dismissed_time
FROM   CLOUDGUARD_APP.CG_EVENTS_CANON
WHERE  event_kind = 'DISMISSED'
GROUP  BY problem_id;

(Optional) Sightings context (earliest sighting)
CREATE OR REPLACE VIEW CLOUDGUARD_APP.CG_SIGHTING_FIRST AS
SELECT problem_id, MIN(event_time) AS first_sighting_time
FROM   CLOUDGUARD_APP.CG_EVENTS_CANON
WHERE  event_kind = 'SIGHTING'
GROUP  BY problem_id;

Detection â†’ Remediation/Dismissal alignment (with timings)
CREATE OR REPLACE VIEW CLOUDGUARD_APP.CG_DETECT_VS_CLOSE AS
SELECT
  d.problem_id,
  d.first_detected_time,
  r.remediated_time,
  x.dismissed_time,
  -- first close event after detection (if any)
  CASE
    WHEN r.remediated_time IS NOT NULL AND x.dismissed_time IS NOT NULL
      THEN LEAST(r.remediated_time, x.dismissed_time)
    WHEN r.remediated_time IS NOT NULL THEN r.remediated_time
    WHEN x.dismissed_time  IS NOT NULL THEN x.dismissed_time
    ELSE NULL
  END AS first_close_time,
  CASE
    WHEN r.remediated_time IS NOT NULL AND (x.dismissed_time IS NULL OR r.remediated_time <= x.dismissed_time)
         AND r.remediated_time >= d.first_detected_time
      THEN 'REMEDIATED'
    WHEN x.dismissed_time IS NOT NULL AND (r.remediated_time IS NULL OR x.dismissed_time < r.remediated_time)
         AND x.dismissed_time >= d.first_detected_time
      THEN 'DISMISSED'
    ELSE NULL
  END AS closure_type,
  CASE
    WHEN r.remediated_time IS NOT NULL AND r.remediated_time >= d.first_detected_time THEN 'YES' ELSE 'NO'
  END AS remediated_explicit,
  CASE
    WHEN (r.remediated_time IS NOT NULL AND r.remediated_time >= d.first_detected_time)
      OR (x.dismissed_time  IS NOT NULL AND x.dismissed_time  >= d.first_detected_time)
      THEN 'YES' ELSE 'NO'
  END AS closed_either,  -- either remediated OR dismissed
  CASE
    WHEN r.remediated_time IS NOT NULL THEN ROUND( (CAST(r.remediated_time AS DATE) - CAST(d.first_detected_time AS DATE)), 4 )
  END AS ttr_days,  -- time to remediate (explicit)
  CASE
    WHEN x.dismissed_time IS NOT NULL THEN ROUND( (CAST(x.dismissed_time AS DATE) - CAST(d.first_detected_time AS DATE)), 4 )
  END AS ttd_days,  -- time to dismiss
  d.risk_at_detection,
  d.severity_at_detection,
  d.severity_rank_at_detection,
  d.compartment_name,
  d.region
FROM CLOUDGUARD_APP.CG_DETECTED_OPEN d
LEFT JOIN CLOUDGUARD_APP.CG_REMEDIATED_BY_EVENT r ON r.problem_id = d.problem_id
LEFT JOIN CLOUDGUARD_APP.CG_DISMISSED_BY_EVENT  x ON x.problem_id = d.problem_id;

(Optional) Reopens after a close (quality signal)
CREATE OR REPLACE VIEW CLOUDGUARD_APP.CG_DETECT_VS_CLOSE_REOPEN AS
SELECT c.*,
       CASE
         WHEN c.first_close_time IS NOT NULL AND EXISTS (
           SELECT 1
           FROM CLOUDGUARD_APP.CG_EVENTS_CANON e
           WHERE e.problem_id = c.problem_id
             AND e.event_time > c.first_close_time
             AND UPPER(e.lifecycle_state) = 'OPEN'
         ) THEN 'YES' ELSE 'NO'
       END AS reopened_after_close
FROM CLOUDGUARD_APP.CG_DETECT_VS_CLOSE c;

Daily cohort stats (detected vs closed types)
CREATE OR REPLACE VIEW CLOUDGUARD_APP.CG_COHORT_DAILY AS
SELECT
  TRUNC(first_detected_time) AS day,
  COUNT(*)                   AS problems_detected,
  SUM(CASE WHEN remediated_explicit = 'YES' THEN 1 ELSE 0 END) AS remediated_explicit_cnt,
  SUM(CASE WHEN closure_type = 'DISMISSED'   THEN 1 ELSE 0 END) AS dismissed_cnt,
  SUM(CASE WHEN closed_either = 'YES'        THEN 1 ELSE 0 END) AS closed_either_cnt
FROM CLOUDGUARD_APP.CG_DETECT_VS_CLOSE
GROUP BY TRUNC(first_detected_time);

100 * (
  SUM(CASE WHEN "REMEDIATED_EXPLICIT" = 'YES' THEN 1 ELSE 0 END)
  / NULLIF(COUNT("PROBLEM_ID"), 0)
)

100 * (
  SUM(CASE WHEN "CLOSURE_TYPE" = 'DISMISSED' THEN 1 ELSE 0 END)
  / NULLIF(COUNT("PROBLEM_ID"), 0)
)

100 * (
  SUM(CASE WHEN "CLOSED_EITHER" = 'YES' THEN 1 ELSE 0 END)
  / NULLIF(COUNT("PROBLEM_ID"), 0)
)


SELECT problem_id, first_detected_time, remediated_time, dismissed_time
FROM   CLOUDGUARD_APP.CG_DETECT_VS_CLOSE
WHERE  remediated_time < first_detected_time
   OR  dismissed_time  < first_detected_time
FETCH FIRST 50 ROWS ONLY;


CREATE OR REPLACE VIEW CLOUDGUARD_APP.CG_DETECT_VS_CLOSE AS
WITH close_events AS (
  SELECT e.problem_id, e.event_kind, e.event_time
  FROM   CLOUDGUARD_APP.CG_EVENTS_CANON e
  WHERE  e.event_kind IN ('REMEDIATED','DISMISSED')
),
agg AS (
  SELECT
    d.problem_id,
    d.first_detected_time,
    /* only close events on/after first detection */
    MIN(CASE WHEN ce.event_kind = 'REMEDIATED' THEN ce.event_time END) AS remediated_time,
    MIN(CASE WHEN ce.event_kind = 'DISMISSED'  THEN ce.event_time END) AS dismissed_time,
    /* carry context */
    d.risk_at_detection,
    d.severity_at_detection,
    d.severity_rank_at_detection,
    d.compartment_name,
    d.region
  FROM CLOUDGUARD_APP.CG_DETECTED_OPEN d
  LEFT JOIN close_events ce
    ON ce.problem_id = d.problem_id
   AND ce.event_time >= d.first_detected_time
  GROUP BY
    d.problem_id,
    d.first_detected_time,
    d.risk_at_detection,
    d.severity_at_detection,
    d.severity_rank_at_detection,
    d.compartment_name,
    d.region
)
SELECT
  a.problem_id,
  a.first_detected_time,
  a.remediated_time,
  a.dismissed_time,
  /* first close = earliest of the two (if any) */
  CASE
    WHEN a.remediated_time IS NULL AND a.dismissed_time IS NULL THEN NULL
    ELSE LEAST(
           NVL(a.remediated_time, TIMESTAMP '9999-12-31 00:00:00'),
           NVL(a.dismissed_time,  TIMESTAMP '9999-12-31 00:00:00')
         )
  END AS first_close_time,
  /* closure type decided by which is earliest */
  CASE
    WHEN a.remediated_time IS NOT NULL
     AND (a.dismissed_time IS NULL OR a.remediated_time <= a.dismissed_time)
      THEN 'REMEDIATED'
    WHEN a.dismissed_time  IS NOT NULL
      THEN 'DISMISSED'
    ELSE NULL
  END AS closure_type,
  /* flags */
  CASE WHEN a.remediated_time IS NOT NULL THEN 'YES' ELSE 'NO' END AS remediated_explicit,
  CASE WHEN a.remediated_time IS NOT NULL OR a.dismissed_time IS NOT NULL THEN 'YES' ELSE 'NO' END AS closed_either,
  /* durations (days) */
  CASE WHEN a.remediated_time IS NOT NULL
       THEN ROUND(CAST(a.remediated_time AS DATE) - CAST(a.first_detected_time AS DATE), 4) END AS ttr_days,
  CASE WHEN a.dismissed_time IS NOT NULL
       THEN ROUND(CAST(a.dismissed_time  AS DATE) - CAST(a.first_detected_time AS DATE), 4) END AS ttd_days,
  /* context */
  a.risk_at_detection,
  a.severity_at_detection,
  a.severity_rank_at_detection,
  a.compartment_name,
  a.region
FROM agg a;






SELECT COUNT(*) bad_rows
FROM   CLOUDGUARD_APP.CG_DETECT_VS_CLOSE
WHERE  remediated_time < first_detected_time
   OR  dismissed_time  < first_detected_time;







