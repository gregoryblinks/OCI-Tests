-- User for the pipeline
CREATE USER CLOUDGUARD_APP IDENTIFIED BY "CGADW_test0987//";
GRANT CONNECT, RESOURCE TO CLOUDGUARD_APP;
GRANT CREATE VIEW TO CLOUDGUARD_APP;

ALTER USER CLOUDGUARD_APP QUOTA UNLIMITED ON DATA;

-- Findings table (flat + raw JSON)
CREATE TABLE CLOUDGUARD_APP.CLOUDGUARD_FINDINGS (
  EVENT_TIME          TIMESTAMP,
  EVENT_TYPE          VARCHAR2(100),
  CLOUD_EVENTS_VERSION VARCHAR2(20),
  PAYLOAD_VERSION     VARCHAR2(20),
  SOURCE              VARCHAR2(100),
  EVENT_ID            VARCHAR2(200),
  TENANT_ID           VARCHAR2(200),
  COMPARTMENT_ID      VARCHAR2(200),
  EXTENSIONS_COMPARTMENT_ID VARCHAR2(200),
  COMPARTMENT_NAME    VARCHAR2(200),
  REGION              VARCHAR2(50),
  PROBLEM_ID          VARCHAR2(200),
  PROBLEM_NAME        VARCHAR2(200),
  PROBLEM_DISPLAY_NAME VARCHAR2(200),
  PROBLEM_TYPE        VARCHAR2(100),
  REASON              VARCHAR2(200),
  SEVERITY            VARCHAR2(20),
  SEVERITY_RANK       NUMBER,
  RISK_LEVEL          VARCHAR2(20),
  RESOURCE_TYPE       VARCHAR2(50),
  RESOURCE_NAME       VARCHAR2(200),
  RESOURCE_ID         VARCHAR2(200),
  TARGET_ID           VARCHAR2(200),
  LIFECYCLE_STATE     VARCHAR2(30),
  PROBLEM_DESCRIPTION CLOB,
  RECOMMENDATION      CLOB,
  FIRST_DETECTED      TIMESTAMP,
  LAST_DETECTED       TIMESTAMP,
  LABELS              VARCHAR2(4000),
  ADDITIONAL_DETAILS_JSON CLOB,
  RAW_EVENT_JSON      CLOB,
  INSERTED_AT         TIMESTAMP DEFAULT SYSTIMESTAMP,
  CONSTRAINT CG_FINDINGS_PK PRIMARY KEY (EVENT_ID)
);

CREATE INDEX CG_IDX_EVTIME ON CLOUDGUARD_APP.CLOUDGUARD_FINDINGS(EVENT_TIME);
CREATE INDEX CG_IDX_SEV    ON CLOUDGUARD_APP.CLOUDGUARD_FINDINGS(SEVERITY_RANK);
CREATE INDEX CG_IDX_COMP   ON CLOUDGUARD_APP.CLOUDGUARD_FINDINGS(COMPARTMENT_NAME);
CREATE INDEX CG_ECANON_I1 ON CLOUDGUARD_APP.CG_EVENTS_CANON (PROBLEM_ID, EVENT_KIND, EVENT_TIME);
CREATE INDEX CG_DETOPEN_I1 ON CLOUDGUARD_APP.CG_DETECTED_OPEN (PROBLEM_ID, FIRST_DETECTED_TIME);


SELECT COUNT(*) FROM CLOUDGUARD_APP.CLOUDGUARD_FINDINGS;
SELECT EVENT_TIME, SEVERITY, COMPARTMENT_NAME, PROBLEM_NAME
FROM CLOUDGUARD_APP.CLOUDGUARD_FINDINGS
ORDER BY INSERTED_AT DESC FETCH FIRST 10 ROWS ONLY;

-- Fill SEVERITY from RISK_LEVEL where it's NULL
UPDATE CLOUDGUARD_APP.CLOUDGUARD_FINDINGS
   SET SEVERITY = UPPER(RISK_LEVEL)
 WHERE SEVERITY IS NULL;

-- Ensure SEVERITY_RANK matches the final value
UPDATE CLOUDGUARD_APP.CLOUDGUARD_FINDINGS
   SET SEVERITY_RANK =
       CASE
         WHEN UPPER(COALESCE(SEVERITY, RISK_LEVEL)) = 'CRITICAL' THEN 4
         WHEN UPPER(COALESCE(SEVERITY, RISK_LEVEL)) IN ('HIGH','MAJOR') THEN 3
         WHEN UPPER(COALESCE(SEVERITY, RISK_LEVEL)) IN ('MEDIUM','MINOR') THEN 2
         WHEN UPPER(COALESCE(SEVERITY, RISK_LEVEL)) = 'LOW' THEN 1
         ELSE 0
       END
 WHERE SEVERITY_RANK IS NULL OR SEVERITY IS NULL;



Canonicalize the event types (single source for the rest)

CREATE OR REPLACE VIEW CLOUDGUARD_APP.CG_EVENTS_CANON AS
SELECT
  -- If your EVENT_TIME is TIMESTAMP WITHOUT TZ in UTC, you can wrap it as:
  -- FROM_TZ(event_time, 'UTC') AS event_time_tz
  event_time,
  UPPER(event_type) AS event_type_u,
  CASE
    WHEN UPPER(event_type) = 'COM.ORACLECLOUD.CLOUDGUARD.PROBLEMDETECTED'   THEN 'DETECTED'
    WHEN UPPER(event_type) = 'COM.ORACLECLOUD.CLOUDGUARD.PROBLEMREMEDIATED' THEN 'REMEDIATED'
    WHEN UPPER(event_type) = 'COM.ORACLECLOUD.CLOUDGUARD.PROBLEMDISMISSED'  THEN 'DISMISSED'
    WHEN UPPER(event_type) = 'COM.ORACLECLOUD.CLOUDGUARD.SIGHTINGDETECTED'  THEN 'SIGHTING'
    ELSE 'OTHER'
  END AS event_kind,
  problem_id,
  UPPER(NVL(lifecycle_state, additional_lifecycle_state)) AS lifecycle_state,
  -- carry severity/risk/ctx as provided by your function
  severity,
  severity_rank,
  risk_level,
  compartment_name,
  region,
  problem_name,
  resource_type,
  resource_id
FROM CLOUDGUARD_APP.CLOUDGUARD_FINDINGS;


First time the problem was detected OPEN
CREATE OR REPLACE VIEW CLOUDGUARD_APP.CG_DETECTED_OPEN AS
WITH first_det AS (
  SELECT problem_id, MIN(event_time) AS first_detected_time
  FROM   CLOUDGUARD_APP.CG_EVENTS_CANON
  WHERE  event_kind = 'DETECTED' AND UPPER(lifecycle_state) = 'OPEN'
  GROUP  BY problem_id
),
span AS (
  SELECT e.*, d.first_detected_time
  FROM   CLOUDGUARD_APP.CG_EVENTS_CANON e
  JOIN   first_det d
    ON   e.problem_id = d.problem_id
   AND   e.event_time >= d.first_detected_time
)
SELECT
  problem_id,
  first_detected_time,

  MAX(risk_level) KEEP (
    DENSE_RANK FIRST ORDER BY CASE WHEN risk_level IS NULL THEN TIMESTAMP '9999-12-31 00:00:00' ELSE event_time END
  ) AS risk_at_detection,

  MAX(severity) KEEP (
    DENSE_RANK FIRST ORDER BY CASE WHEN severity IS NULL THEN TIMESTAMP '9999-12-31 00:00:00' ELSE event_time END
  ) AS severity_at_detection,

  MAX(severity_rank) KEEP (
    DENSE_RANK FIRST ORDER BY CASE WHEN severity_rank IS NULL THEN TIMESTAMP '9999-12-31 00:00:00' ELSE event_time END
  ) AS severity_rank_at_detection,

  MAX(compartment_name) KEEP (
    DENSE_RANK FIRST ORDER BY CASE WHEN compartment_name IS NULL THEN TIMESTAMP '9999-12-31 00:00:00' ELSE event_time END
  ) AS compartment_name_at_detection,

  MAX(region) KEEP (
    DENSE_RANK FIRST ORDER BY CASE WHEN region IS NULL THEN TIMESTAMP '9999-12-31 00:00:00' ELSE event_time END
  ) AS region_at_detection,

  MAX(problem_name) KEEP (
    DENSE_RANK FIRST ORDER BY CASE WHEN problem_name IS NULL THEN TIMESTAMP '9999-12-31 00:00:00' ELSE event_time END
  ) AS problem_name_at_detection,

  MAX(resource_type) KEEP (
    DENSE_RANK FIRST ORDER BY CASE WHEN resource_type IS NULL THEN TIMESTAMP '9999-12-31 00:00:00' ELSE event_time END
  ) AS resource_type_at_detection
FROM span
GROUP BY problem_id, first_detected_time;


CREATE OR REPLACE VIEW CLOUDGUARD_APP.CG_DISMISSED_BY_EVENT AS
SELECT problem_id, MIN(event_time) AS dismissed_time
FROM   CLOUDGUARD_APP.CG_EVENTS_CANON
WHERE  event_kind = 'DISMISSED'
GROUP  BY problem_id;

(Optional) Sightings context (earliest sighting)
CREATE OR REPLACE VIEW CLOUDGUARD_APP.CG_SIGHTING_FIRST AS
SELECT problem_id, MIN(event_time) AS first_sighting_time
FROM   CLOUDGUARD_APP.CG_EVENTS_CANON
WHERE  event_kind = 'SIGHTING'
GROUP  BY problem_id;

Detection â†’ Remediation/Dismissal alignment (with timings)
CREATE OR REPLACE VIEW CLOUDGUARD_APP.CG_DETECT_VS_CLOSE AS
WITH close_events AS (
  SELECT e.problem_id, e.event_kind, e.event_time
  FROM   CLOUDGUARD_APP.CG_EVENTS_CANON e
  WHERE  e.event_kind IN ('REMEDIATED','DISMISSED')
),
agg AS (
  SELECT
    d.problem_id,
    d.first_detected_time,
    MIN(CASE WHEN ce.event_kind = 'REMEDIATED' THEN ce.event_time END) AS remediated_time,
    MIN(CASE WHEN ce.event_kind = 'DISMISSED'  THEN ce.event_time END) AS dismissed_time,
    -- carry context
    d.risk_at_detection,
    d.severity_at_detection,
    d.severity_rank_at_detection,
    d.compartment_name_at_detection,
    d.region_at_detection,
    d.problem_name_at_detection,
    d.resource_type_at_detection
  FROM CLOUDGUARD_APP.CG_DETECTED_OPEN d
  LEFT JOIN close_events ce
    ON ce.problem_id = d.problem_id
   AND ce.event_time >= d.first_detected_time
  GROUP BY
    d.problem_id, d.first_detected_time,
    d.risk_at_detection, d.severity_at_detection, d.severity_rank_at_detection,
    d.compartment_name_at_detection, d.region_at_detection,
    d.problem_name_at_detection, d.resource_type_at_detection
)
SELECT
  a.problem_id,
  a.first_detected_time,
  a.remediated_time,
  a.dismissed_time,
  CASE
    WHEN a.remediated_time IS NULL AND a.dismissed_time IS NULL THEN NULL
    ELSE LEAST(
           NVL(a.remediated_time, TIMESTAMP '9999-12-31 00:00:00'),
           NVL(a.dismissed_time,  TIMESTAMP '9999-12-31 00:00:00')
         )
  END AS first_close_time,
  CASE
    WHEN a.remediated_time IS NOT NULL
     AND (a.dismissed_time IS NULL OR a.remediated_time <= a.dismissed_time)
      THEN 'REMEDIATED'
    WHEN a.dismissed_time  IS NOT NULL
      THEN 'DISMISSED'
    ELSE NULL
  END AS closure_type,
  CASE WHEN a.remediated_time IS NOT NULL THEN 'YES' ELSE 'NO' END AS remediated_explicit,
  CASE WHEN a.remediated_time IS NOT NULL OR a.dismissed_time IS NOT NULL THEN 'YES' ELSE 'NO' END AS closed_either,
  CASE WHEN a.remediated_time IS NOT NULL
       THEN ROUND(CAST(a.remediated_time AS DATE) - CAST(a.first_detected_time AS DATE), 4)
  END AS ttr_days,
  CASE WHEN a.dismissed_time IS NOT NULL
       THEN ROUND(CAST(a.dismissed_time  AS DATE) - CAST(a.first_detected_time AS DATE), 4)
  END AS ttd_days,
  -- friendly context columns
  a.problem_name_at_detection AS problem_name,
  UPPER(NVL(a.severity_at_detection, a.risk_at_detection)) AS severity_bucket,
  a.risk_at_detection,
  a.severity_at_detection,
  a.severity_rank_at_detection,
  a.compartment_name_at_detection AS compartment_name,
  a.region_at_detection          AS region,
  a.resource_type_at_detection   AS resource_type
FROM agg a;


Daily cohort stats (detected vs closed types)
CREATE OR REPLACE VIEW CLOUDGUARD_APP.CG_COHORT_DAILY AS
SELECT
  TRUNC(CAST(first_detected_time AT TIME ZONE 'Europe/Berlin' AS DATE)) AS detect_day_local,
  COUNT(*) AS detected_total,
  SUM(CASE WHEN remediated_time IS NOT NULL THEN 1 ELSE 0 END) AS remediated_total,
  SUM(CASE WHEN dismissed_time  IS NOT NULL THEN 1 ELSE 0 END) AS dismissed_total,
  ROUND(SUM(CASE WHEN remediated_time IS NOT NULL THEN 1 ELSE 0 END) / NULLIF(COUNT(*),0), 4) AS remediation_rate
FROM CLOUDGUARD_APP.CG_DETECT_VS_CLOSE
GROUP BY TRUNC(CAST(first_detected_time AT TIME ZONE 'Europe/Berlin' AS DATE));


100 * (
  SUM(CASE WHEN "REMEDIATED_EXPLICIT" = 'YES' THEN 1 ELSE 0 END)
  / NULLIF(COUNT("PROBLEM_ID"), 0)
)

100 * (
  SUM(CASE WHEN "CLOSURE_TYPE" = 'DISMISSED' THEN 1 ELSE 0 END)
  / NULLIF(COUNT("PROBLEM_ID"), 0)
)

100 * (
  SUM(CASE WHEN "CLOSED_EITHER" = 'YES' THEN 1 ELSE 0 END)
  / NULLIF(COUNT("PROBLEM_ID"), 0)
)


SELECT problem_id, first_detected_time, remediated_time, dismissed_time
FROM   CLOUDGUARD_APP.CG_DETECT_VS_CLOSE
WHERE  remediated_time < first_detected_time
   OR  dismissed_time  < first_detected_time
FETCH FIRST 50 ROWS ONLY;

#################################################################################
CREATE OR REPLACE VIEW CLOUDGUARD_APP.CG_DETECT_VS_CLOSE AS
WITH close_events AS (
  SELECT e.problem_id, e.event_kind, e.event_time
  FROM   CLOUDGUARD_APP.CG_EVENTS_CANON e
  WHERE  e.event_kind IN ('REMEDIATED','DISMISSED')
),
agg AS (
  SELECT
    d.problem_id,
    d.first_detected_time,
    /* only close events on/after first detection */
    MIN(CASE WHEN ce.event_kind = 'REMEDIATED' THEN ce.event_time END) AS remediated_time,
    MIN(CASE WHEN ce.event_kind = 'DISMISSED'  THEN ce.event_time END) AS dismissed_time,
    /* carry context */
    d.risk_at_detection,
    d.severity_at_detection,
    d.severity_rank_at_detection,
    d.compartment_name,
    d.region
  FROM CLOUDGUARD_APP.CG_DETECTED_OPEN d
  LEFT JOIN close_events ce
    ON ce.problem_id = d.problem_id
   AND ce.event_time >= d.first_detected_time
  GROUP BY
    d.problem_id,
    d.first_detected_time,
    d.risk_at_detection,
    d.severity_at_detection,
    d.severity_rank_at_detection,
    d.compartment_name,
    d.region
)
SELECT
  a.problem_id,
  a.first_detected_time,
  a.remediated_time,
  a.dismissed_time,
  /* first close = earliest of the two (if any) */
  CASE
    WHEN a.remediated_time IS NULL AND a.dismissed_time IS NULL THEN NULL
    ELSE LEAST(
           NVL(a.remediated_time, TIMESTAMP '9999-12-31 00:00:00'),
           NVL(a.dismissed_time,  TIMESTAMP '9999-12-31 00:00:00')
         )
  END AS first_close_time,
  /* closure type decided by which is earliest */
  CASE
    WHEN a.remediated_time IS NOT NULL
     AND (a.dismissed_time IS NULL OR a.remediated_time <= a.dismissed_time)
      THEN 'REMEDIATED'
    WHEN a.dismissed_time  IS NOT NULL
      THEN 'DISMISSED'
    ELSE NULL
  END AS closure_type,
  /* flags */
  CASE WHEN a.remediated_time IS NOT NULL THEN 'YES' ELSE 'NO' END AS remediated_explicit,
  CASE WHEN a.remediated_time IS NOT NULL OR a.dismissed_time IS NOT NULL THEN 'YES' ELSE 'NO' END AS closed_either,
  /* durations (days) */
  CASE WHEN a.remediated_time IS NOT NULL
       THEN ROUND(CAST(a.remediated_time AS DATE) - CAST(a.first_detected_time AS DATE), 4) END AS ttr_days,
  CASE WHEN a.dismissed_time IS NOT NULL
       THEN ROUND(CAST(a.dismissed_time  AS DATE) - CAST(a.first_detected_time AS DATE), 4) END AS ttd_days,
  /* context */
  a.risk_at_detection,
  a.severity_at_detection,
  a.severity_rank_at_detection,
  a.compartment_name,
  a.region
FROM agg a;
################################################################################################################

CREATE OR REPLACE VIEW CLOUDGUARD_APP.CG_PROBLEM_LATEST AS
WITH last_evt AS (
  SELECT problem_id, MAX(event_time) AS last_time
  FROM   CLOUDGUARD_APP.CG_EVENTS_CANON
  GROUP  BY problem_id
)
SELECT
  e.problem_id,
  e.event_time      AS current_event_time,
  e.event_kind      AS current_event_kind,
  UPPER(NVL(e.lifecycle_state,
            CASE WHEN e.event_kind='REMEDIATED' THEN 'RESOLVED'
                 WHEN e.event_kind='DISMISSED'  THEN 'DISMISSED'
                 WHEN e.event_kind='DETECTED'   THEN 'OPEN'
                 ELSE 'UNKNOWN' END)) AS current_state
FROM CLOUDGUARD_APP.CG_EVENTS_CANON e
JOIN last_evt l
  ON l.problem_id = e.problem_id
 AND l.last_time  = e.event_time;


-- No â€œclose before detectionâ€ remains
SELECT COUNT(*) bad_rows
FROM   CLOUDGUARD_APP.CG_DETECT_VS_CLOSE
WHERE  remediated_time < first_detected_time
   OR  dismissed_time  < first_detected_time;

-- Remediated today (Berlin) shows up in activity
SELECT remediated_total
FROM   CLOUDGUARD_APP.CG_ACTIVITY_DAILY_LOCAL
WHERE  day_local = TRUNC(CAST(SYSTIMESTAMP AT TIME ZONE 'Europe/Berlin' AS DATE));





SELECT COUNT(*) bad_rows
FROM   CLOUDGUARD_APP.CG_DETECT_VS_CLOSE
WHERE  remediated_time < first_detected_time
   OR  dismissed_time  < first_detected_time;


-- Distinct problem names that were ever classified as CRITICAL
SELECT DISTINCT problem_name
FROM   CLOUDGUARD_APP.CLOUDGUARD_FINDINGS
WHERE  UPPER(COALESCE(severity, risk_level)) = 'CRITICAL';



CREATE OR REPLACE VIEW CLOUDGUARD_APP.CG_COHORT_DAILY_SEV AS
WITH base AS (
  SELECT
    TRUNC(first_detected_time)                                       AS day,
    UPPER(NVL(severity_at_detection, risk_at_detection))             AS sev,
    CASE WHEN remediated_time IS NOT NULL THEN 1 ELSE 0 END          AS rem_flg
  FROM CLOUDGUARD_APP.CG_DETECT_VS_CLOSE
),
agg AS (
  SELECT
    day,
    COUNT(*)                                                         AS detected_total,

    /* detected by severity */
    SUM(CASE WHEN sev = 'CRITICAL'                THEN 1 ELSE 0 END) AS detected_critical,
    SUM(CASE WHEN sev IN ('HIGH','MAJOR')         THEN 1 ELSE 0 END) AS detected_high,
    SUM(CASE WHEN sev IN ('MEDIUM','MODERATE')    THEN 1 ELSE 0 END) AS detected_medium,
    SUM(CASE WHEN sev = 'LOW'                     THEN 1 ELSE 0 END) AS detected_low,
    SUM(CASE WHEN sev = 'MINOR'                   THEN 1 ELSE 0 END) AS detected_minor,

    /* remediated (explicit problemremediated) totals and by severity */
    SUM(rem_flg)                                                     AS remediated_total,
    SUM(CASE WHEN sev = 'CRITICAL'                THEN rem_flg ELSE 0 END) AS remediated_critical,
    SUM(CASE WHEN sev IN ('HIGH','MAJOR')         THEN rem_flg ELSE 0 END) AS remediated_high,
    SUM(CASE WHEN sev IN ('MEDIUM','MODERATE')    THEN rem_flg ELSE 0 END) AS remediated_medium,
    SUM(CASE WHEN sev = 'LOW'                     THEN rem_flg ELSE 0 END) AS remediated_low,
    SUM(CASE WHEN sev = 'MINOR'                   THEN rem_flg ELSE 0 END) AS remediated_minor
  FROM base
  GROUP BY day
)
SELECT
  a.*,

  /* overall remediation rate */
  ROUND(a.remediated_total / NULLIF(a.detected_total,0), 4)                AS rate_total,

  /* remediation rate by severity */
  ROUND(a.remediated_critical / NULLIF(a.detected_critical,0), 4)          AS rate_critical,
  ROUND(a.remediated_high     / NULLIF(a.detected_high,0), 4)              AS rate_high,
  ROUND(a.remediated_medium   / NULLIF(a.detected_medium,0), 4)            AS rate_medium,
  ROUND(a.remediated_low      / NULLIF(a.detected_low,0), 4)               AS rate_low,
  ROUND(a.remediated_minor    / NULLIF(a.detected_minor,0), 4)             AS rate_minor
FROM agg a;


Top problem names with the lowest explicit remediation rate (require at least 5 detections to avoid noise):
-- Top problem names with low remediation rate
WITH cohort AS (
  SELECT
    c.problem_id,
    c.first_detected_time,
    c.remediated_time,
    c.dismissed_time,
    c.closure_type,
    /* earliest non-null name at/after detection for this problem_id */
    (SELECT MAX(f.problem_name) KEEP (
       DENSE_RANK FIRST ORDER BY
         CASE WHEN f.problem_name IS NULL
              THEN TIMESTAMP '9999-12-31 00:00:00' ELSE f.event_time END)
     FROM CLOUDGUARD_APP.CLOUDGUARD_FINDINGS f
     WHERE f.problem_id = c.problem_id
       AND f.event_time >= c.first_detected_time) AS problem_name
  FROM CLOUDGUARD_APP.CG_DETECT_VS_CLOSE c
)
SELECT
  problem_name,
  COUNT(*) AS detected,
  SUM(CASE WHEN remediated_time IS NOT NULL THEN 1 ELSE 0 END) AS remediated,
  SUM(CASE WHEN closure_type = 'DISMISSED' THEN 1 ELSE 0 END) AS dismissed,
  SUM(CASE WHEN remediated_time IS NULL AND NVL(closure_type,'') <> 'DISMISSED' THEN 1 ELSE 0 END) AS still_open,
  ROUND( SUM(CASE WHEN remediated_time IS NOT NULL THEN 1 ELSE 0 END) / NULLIF(COUNT(*),0), 4) AS remediation_rate,
  ROUND( SUM(CASE WHEN closure_type = 'DISMISSED' THEN 1 ELSE 0 END) / NULLIF(COUNT(*),0), 4) AS dismissal_rate
FROM cohort
GROUP BY problem_name
HAVING COUNT(*) >= 5
ORDER BY remediation_rate ASC, detected DESC
FETCH FIRST 20 ROWS ONLY;


Interpretation
1.  remediation_rate low â†’ these problem names are the ones â€œmostly not remediatedâ€.
2.  Check dismissal_rate vs still_open to see whether theyâ€™re being dismissed or just lingering open.


2) Why? (diagnose a specific problem name)
ðŸ‘‰ Replace :pname with the problem name you want to analyze.

2A. Outcome split (remediated vs dismissed vs still open)
WITH cohort AS (
  SELECT c.*
  FROM   CLOUDGUARD_APP.CG_DETECT_VS_CLOSE c
  WHERE EXISTS (
    SELECT 1
    FROM   CLOUDGUARD_APP.CLOUDGUARD_FINDINGS f
    WHERE  f.problem_id = c.problem_id
      AND  f.event_time >= c.first_detected_time
      AND  f.problem_name = :pname
  )
)
SELECT 'REMEDIATED' AS outcome, COUNT(*) AS cnt
FROM   cohort
WHERE  remediated_time IS NOT NULL
UNION ALL
SELECT 'DISMISSED', COUNT(*)
FROM   cohort
WHERE  closure_type = 'DISMISSED'
UNION ALL
SELECT 'STILL_OPEN', COUNT(*)
FROM   cohort
WHERE  remediated_time IS NULL AND NVL(closure_type,'') <> 'DISMISSED';


2B) By severity/risk at detection (non-remediated only)
WITH cohort AS (
  SELECT c.*
  FROM   CLOUDGUARD_APP.CG_DETECT_VS_CLOSE c
  WHERE EXISTS (
    SELECT 1 FROM CLOUDGUARD_APP.CLOUDGUARD_FINDINGS f
    WHERE  f.problem_id = c.problem_id
      AND  f.event_time >= c.first_detected_time
      AND  f.problem_name = :pname
  )
)
SELECT
  UPPER(NVL(severity_at_detection, risk_at_detection)) AS severity_bucket,
  COUNT(*) AS detected,
  SUM(CASE WHEN remediated_time IS NULL AND NVL(closure_type,'') <> 'DISMISSED' THEN 1 ELSE 0 END) AS still_open,
  SUM(CASE WHEN closure_type = 'DISMISSED' THEN 1 ELSE 0 END) AS dismissed,
  ROUND(
    SUM(CASE WHEN remediated_time IS NOT NULL THEN 1 END)
    / NULLIF(COUNT(*),0), 4
  ) AS remediation_rate
FROM cohort
GROUP BY UPPER(NVL(severity_at_detection, risk_at_detection))
ORDER BY remediation_rate ASC, detected DESC;


2C) Top compartments where itâ€™s not remediated
WITH cohort AS (
  SELECT c.*
  FROM   CLOUDGUARD_APP.CG_DETECT_VS_CLOSE c
  WHERE EXISTS (
    SELECT 1 FROM CLOUDGUARD_APP.CLOUDGUARD_FINDINGS f
    WHERE  f.problem_id = c.problem_id
      AND  f.event_time >= c.first_detected_time
      AND  f.problem_name = :pname
  )
)
SELECT
  compartment_name,
  COUNT(*) AS detected,
  SUM(CASE WHEN remediated_time IS NOT NULL THEN 1 ELSE 0 END) AS remediated,
  SUM(CASE WHEN closure_type = 'DISMISSED' THEN 1 ELSE 0 END) AS dismissed,
  SUM(CASE WHEN remediated_time IS NULL AND NVL(closure_type,'') <> 'DISMISSED' THEN 1 ELSE 0 END) AS still_open,
  ROUND(
    SUM(CASE WHEN remediated_time IS NOT NULL THEN 1 END)
    / NULLIF(COUNT(*),0), 4
  ) AS remediation_rate
FROM cohort
GROUP BY compartment_name
HAVING COUNT(*) >= 3
ORDER BY remediation_rate ASC, detected DESC
FETCH FIRST 10 ROWS ONLY;

2D) Top resource types where itâ€™s not remediated
WITH cohort AS (
  SELECT
    c.*,
    /* earliest non-null resource_type after detection */
    (SELECT MAX(f.resource_type) KEEP (
       DENSE_RANK FIRST ORDER BY
         CASE WHEN f.resource_type IS NULL
              THEN TIMESTAMP '9999-12-31 00:00:00' ELSE f.event_time END)
     FROM CLOUDGUARD_APP.CLOUDGUARD_FINDINGS f
     WHERE f.problem_id = c.problem_id
       AND f.event_time >= c.first_detected_time) AS resource_type_at_detection
  FROM CLOUDGUARD_APP.CG_DETECT_VS_CLOSE c
  WHERE EXISTS (
    SELECT 1 FROM CLOUDGUARD_APP.CLOUDGUARD_FINDINGS f
    WHERE  f.problem_id = c.problem_id
      AND  f.event_time >= c.first_detected_time
      AND  f.problem_name = :pname
  )
)
SELECT
  resource_type_at_detection AS resource_type,
  COUNT(*) AS detected,
  SUM(CASE WHEN remediated_time IS NOT NULL THEN 1 ELSE 0 END) AS remediated,
  SUM(CASE WHEN closure_type = 'DISMISSED' THEN 1 ELSE 0 END) AS dismissed,
  SUM(CASE WHEN remediated_time IS NULL AND NVL(closure_type,'') <> 'DISMISSED' THEN 1 ELSE 0 END) AS still_open,
  ROUND(
    SUM(CASE WHEN remediated_time IS NOT NULL THEN 1 END)
    / NULLIF(COUNT(*),0), 4
  ) AS remediation_rate
FROM cohort
GROUP BY resource_type_at_detection
HAVING COUNT(*) >= 3
ORDER BY remediation_rate ASC, detected DESC
FETCH FIRST 10 ROWS ONLY;


3) One query to rank â€œnon-remediatedâ€ drivers across all problems
This ranks the combinations of (problem_name, severity_bucket, compartment) where remediation is lowest (and volume â‰¥ 5):

WITH cohort AS (
  SELECT
    c.problem_id,
    c.first_detected_time,
    c.remediated_time,
    c.closure_type,
    UPPER(NVL(c.severity_at_detection, c.risk_at_detection)) AS severity_bucket,
    c.compartment_name,
    (SELECT MAX(f.problem_name) KEEP (
       DENSE_RANK FIRST ORDER BY
         CASE WHEN f.problem_name IS NULL
              THEN TIMESTAMP '9999-12-31 00:00:00' ELSE f.event_time END)
     FROM CLOUDGUARD_APP.CLOUDGUARD_FINDINGS f
     WHERE f.problem_id = c.problem_id
       AND f.event_time >= c.first_detected_time) AS problem_name
  FROM CLOUDGUARD_APP.CG_DETECT_VS_CLOSE c
)
SELECT
  problem_name,
  severity_bucket,
  compartment_name,
  COUNT(*) AS detected,
  SUM(CASE WHEN remediated_time IS NOT NULL THEN 1 ELSE 0 END) AS remediated,
  SUM(CASE WHEN closure_type = 'DISMISSED' THEN 1 ELSE 0 END) AS dismissed,
  SUM(CASE WHEN remediated_time IS NULL AND NVL(closure_type,'') <> 'DISMISSED' THEN 1 ELSE 0 END) AS still_open,
  ROUND( SUM(CASE WHEN remediated_time IS NOT NULL THEN 1 ELSE 0 END) / NULLIF(COUNT(*),0), 4) AS remediation_rate
FROM cohort
GROUP BY problem_name, severity_bucket, compartment_name
HAVING COUNT(*) >= 5
ORDER BY remediation_rate ASC, detected DESC
FETCH FIRST 20 ROWS ONLY;

Use this to answer â€œwhyâ€:
Look at the lowest-rate rowsâ€”do they cluster in certain compartments, risks, or resource types? Thatâ€™s your remediation bottleneck.

One helper view (copyâ€“paste in ADW)
  This wraps your fixed cohort view and adds:
  PROBLEM_NAME (at/after first detection),
  RESOURCE_TYPE (at/after first detection),
  SEVERITY_BUCKET (uses SEVERITY_AT_DETECTION fallback RISK_AT_DETECTION).

CREATE OR REPLACE VIEW CLOUDGUARD_APP.CG_DETECT_VS_CLOSE_NAMED AS
SELECT
  c.problem_id,
  c.first_detected_time,
  c.remediated_time,
  c.dismissed_time,
  c.first_close_time,
  c.closure_type,
  c.remediated_explicit,
  c.closed_either,
  c.ttr_days,
  c.ttd_days,
  c.risk_at_detection,
  c.severity_at_detection,
  c.severity_rank_at_detection,
  c.compartment_name,
  c.region,
  /* derived */
  UPPER(NVL(c.severity_at_detection, c.risk_at_detection)) AS severity_bucket,

  /* earliest non-null name after detection */
  (SELECT MAX(f.problem_name) KEEP (
     DENSE_RANK FIRST ORDER BY
       CASE WHEN f.problem_name IS NULL
            THEN TIMESTAMP '9999-12-31 00:00:00' ELSE f.event_time END)
   FROM CLOUDGUARD_APP.CLOUDGUARD_FINDINGS f
   WHERE f.problem_id = c.problem_id
     AND f.event_time >= c.first_detected_time) AS problem_name,

  /* earliest non-null resource_type after detection */
  (SELECT MAX(f.resource_type) KEEP (
     DENSE_RANK FIRST ORDER BY
       CASE WHEN f.resource_type IS NULL
            THEN TIMESTAMP '9999-12-31 00:00:00' ELSE f.event_time END)
   FROM CLOUDGUARD_APP.CLOUDGUARD_FINDINGS f
   WHERE f.problem_id = c.problem_id
     AND f.event_time >= c.first_detected_time) AS resource_type

FROM CLOUDGUARD_APP.CG_DETECT_VS_CLOSE c;

One unified list with a STATUS column
SELECT
  c.problem_id,
  (SELECT MAX(f.problem_name) KEEP (
           DENSE_RANK FIRST ORDER BY
             CASE WHEN f.problem_name IS NULL
                  THEN TIMESTAMP '9999-12-31 00:00:00' ELSE f.event_time END)
     FROM CLOUDGUARD_APP.CLOUDGUARD_FINDINGS f
     WHERE f.problem_id = c.problem_id
       AND f.event_time >= c.first_detected_time) AS problem_name,
  c.first_detected_time,
  c.remediated_time,
  c.dismissed_time,
  CASE
    WHEN c.remediated_time IS NOT NULL THEN 'REMEDIATED'
    WHEN c.closure_type = 'DISMISSED'  THEN 'DISMISSED'
    ELSE 'OPEN'
  END AS status,
  /* handy metrics */
  CASE WHEN c.remediated_time IS NOT NULL
       THEN ROUND(CAST(c.remediated_time AS DATE) - CAST(c.first_detected_time AS DATE), 4)
  END AS ttr_days,
  CASE WHEN c.remediated_time IS NULL AND NVL(c.closure_type,'') <> 'DISMISSED'
       THEN ROUND(CAST(SYSTIMESTAMP AS DATE) - CAST(c.first_detected_time AS DATE), 4)
  END AS open_age_days,
  UPPER(NVL(c.severity_at_detection, c.risk_at_detection)) AS severity_bucket,
  c.compartment_name,
  c.region
FROM CLOUDGUARD_APP.CG_DETECT_VS_CLOSE c
-- Optional date filter:
-- WHERE c.first_detected_time >= ADD_MONTHS(TRUNC(SYSDATE), -3)
ORDER BY
  CASE
    WHEN c.remediated_time IS NULL AND NVL(c.closure_type,'') <> 'DISMISSED' THEN 1  -- OPEN first
    WHEN c.closure_type = 'DISMISSED' THEN 2
    ELSE 3
  END,
  c.first_detected_time DESC;
####################################
SELECT
  TRUNC(CAST(FROM_TZ(event_time, 'UTC') AT TIME ZONE 'Europe/Berlin' AS DATE)) AS day_local,
  COUNT(DISTINCT CASE
    WHEN UPPER(event_type) = 'COM.ORACLECLOUD.CLOUDGUARD.PROBLEMDETECTED'
    THEN problem_id END) AS detected_problems,
  COUNT(DISTINCT CASE
    WHEN UPPER(event_type) = 'COM.ORACLECLOUD.CLOUDGUARD.PROBLEMREMEDIATED'
    THEN problem_id END) AS remediated_problems
FROM CLOUDGUARD_APP.CLOUDGUARD_FINDINGS
WHERE UPPER(event_type) IN (
  'COM.ORACLECLOUD.CLOUDGUARD.PROBLEMDETECTED',
  'COM.ORACLECLOUD.CLOUDGUARD.PROBLEMREMEDIATED'
)
GROUP BY TRUNC(CAST(FROM_TZ(event_time, 'UTC') AT TIME ZONE 'Europe/Berlin' AS DATE))
ORDER BY day_local;
#####################################
CREATE OR REPLACE VIEW CLOUDGUARD_APP.CG_DETECTED_WITH_RESOLUTION AS
WITH detected AS (
  /* First time each problem was detected (OPEN) */
  SELECT problem_id, MIN(event_time) AS first_detected_time
  FROM   CLOUDGUARD_APP.CLOUDGUARD_FINDINGS
  WHERE  UPPER(event_type) = 'COM.ORACLECLOUD.CLOUDGUARD.PROBLEMDETECTED'
  GROUP  BY problem_id
),
aug AS (
  SELECT
    d.problem_id,
    d.first_detected_time,

    /* Friendly name at/after detection (earliest non-null) */
    ( SELECT MAX(f.problem_name) KEEP (
             DENSE_RANK FIRST ORDER BY
               CASE WHEN f.problem_name IS NULL
                    THEN TIMESTAMP '9999-12-31 00:00:00' ELSE f.event_time END)
      FROM CLOUDGUARD_APP.CLOUDGUARD_FINDINGS f
      WHERE f.problem_id = d.problem_id
        AND f.event_time >= d.first_detected_time
    ) AS problem_name,

    /* First remediation AFTER (or at) detection */
    ( SELECT MIN(f.event_time)
      FROM   CLOUDGUARD_APP.CLOUDGUARD_FINDINGS f
      WHERE  f.problem_id = d.problem_id
        AND  UPPER(f.event_type) = 'COM.ORACLECLOUD.CLOUDGUARD.PROBLEMREMEDIATED'
        AND  f.event_time >= d.first_detected_time
    ) AS remediated_time,

    /* First dismissal AFTER (or at) detection */
    ( SELECT MIN(f.event_time)
      FROM   CLOUDGUARD_APP.CLOUDGUARD_FINDINGS f
      WHERE  f.problem_id = d.problem_id
        AND  UPPER(f.event_type) = 'COM.ORACLECLOUD.CLOUDGUARD.PROBLEMDISMISSED'
        AND  f.event_time >= d.first_detected_time
    ) AS dismissed_time
  FROM detected d
)
SELECT
  problem_id,
  problem_name,
  first_detected_time,
  remediated_time,
  dismissed_time,

  /* Status label */
  CASE
    WHEN remediated_time IS NOT NULL
         AND (dismissed_time IS NULL OR remediated_time <= dismissed_time)
      THEN 'REMEDIATED'
    WHEN dismissed_time IS NOT NULL
      THEN 'DISMISSED'
    ELSE 'OPEN'
  END AS status,

  /* Time to Resolve (days) */
  CASE WHEN remediated_time IS NOT NULL
       THEN ROUND(CAST(remediated_time AS DATE) - CAST(first_detected_time AS DATE), 4)
  END AS ttr_days,

  /* Current open age (days) if still open */
  CASE WHEN remediated_time IS NULL AND dismissed_time IS NULL
       THEN ROUND(CAST(SYSTIMESTAMP AS DATE) - CAST(first_detected_time AS DATE), 4)
  END AS open_age_days

FROM aug;

#####################################
-- Returns rows?
SELECT * FROM CLOUDGUARD_APP.CG_DETECTED_WITH_RESOLUTION
FETCH FIRST 10 ROWS ONLY;

-- Any anomalies (should be 0)?
SELECT COUNT(*) bad_rows
FROM   CLOUDGUARD_APP.CG_DETECTED_WITH_RESOLUTION
WHERE  remediated_time < first_detected_time
   OR  dismissed_time  < first_detected_time;
####################################

WITH rem AS (
  SELECT problem_id, MIN(event_time) AS remediated_time
  FROM   CLOUDGUARD_APP.CLOUDGUARD_FINDINGS
  WHERE  UPPER(event_type) = 'COM.ORACLECLOUD.CLOUDGUARD.PROBLEMREMEDIATED'
  GROUP  BY problem_id
),
det AS (
  SELECT problem_id, MIN(event_time) AS first_detected_time
  FROM   CLOUDGUARD_APP.CLOUDGUARD_FINDINGS
  WHERE  UPPER(event_type) = 'COM.ORACLECLOUD.CLOUDGUARD.PROBLEMDETECTED'
  GROUP  BY problem_id
)
SELECT
  r.problem_id,
  f.problem_name,
  d.first_detected_time,
  r.remediated_time,

  /* Prefer REASON; fallback PROBLEM_DESCRIPTION â€” both normalized to VARCHAR2 */
  COALESCE(
    NULLIF(TRIM(DBMS_LOB.SUBSTR(TO_CLOB(f.reason),               4000)), ''),
    NULLIF(TRIM(DBMS_LOB.SUBSTR(TO_CLOB(f.problem_description),  4000)), '')
  ) AS remediation_reason,

  /* Time-to-resolve (days) */
  CASE WHEN d.first_detected_time IS NOT NULL
       THEN ROUND(CAST(r.remediated_time AS DATE) - CAST(d.first_detected_time AS DATE), 4)
  END AS ttr_days

FROM rem r
JOIN CLOUDGUARD_APP.CLOUDGUARD_FINDINGS f
  ON f.problem_id = r.problem_id
 AND f.event_time = r.remediated_time
 AND UPPER(f.event_type) = 'COM.ORACLECLOUD.CLOUDGUARD.PROBLEMREMEDIATED'
LEFT JOIN det d
  ON d.problem_id = r.problem_id
ORDER BY r.remediated_time DESC;



CREATE OR REPLACE VIEW CLOUDGUARD_APP.CG_REMEDIATED_WITH_REASON AS
WITH rem AS (
  SELECT problem_id, MIN(event_time) AS remediated_time
  FROM   CLOUDGUARD_APP.CLOUDGUARD_FINDINGS
  WHERE  UPPER(event_type) = 'COM.ORACLECLOUD.CLOUDGUARD.PROBLEMREMEDIATED'
  GROUP  BY problem_id
),
det AS (
  SELECT problem_id, MIN(event_time) AS first_detected_time
  FROM   CLOUDGUARD_APP.CLOUDGUARD_FINDINGS
  WHERE  UPPER(event_type) = 'COM.ORACLECLOUD.CLOUDGUARD.PROBLEMDETECTED'
  GROUP  BY problem_id
)
SELECT
  r.problem_id,
  f.problem_name,
  d.first_detected_time,
  r.remediated_time,
  COALESCE(
    NULLIF(TRIM(DBMS_LOB.SUBSTR(TO_CLOB(f.reason),              4000)), ''),
    NULLIF(TRIM(DBMS_LOB.SUBSTR(TO_CLOB(f.problem_description), 4000)), '')
  ) AS remediation_reason,
  CASE WHEN d.first_detected_time IS NOT NULL
       THEN ROUND(CAST(r.remediated_time AS DATE) - CAST(d.first_detected_time AS DATE), 4)
  END AS ttr_days
FROM rem r
JOIN CLOUDGUARD_APP.CLOUDGUARD_FINDINGS f
  ON f.problem_id = r.problem_id
 AND f.event_time = r.remediated_time
 AND UPPER(f.event_type) = 'COM.ORACLECLOUD.CLOUDGUARD.PROBLEMREMEDIATED'
LEFT JOIN det d
  ON d.problem_id = r.problem_id;


-- Confirm datatypes so we know why it failed before
SELECT column_name, data_type
FROM   all_tab_columns
WHERE  owner='CLOUDGUARD_APP'
  AND  table_name='CLOUDGUARD_FINDINGS'
  AND  column_name IN ('REASON','PROBLEM_DESCRIPTION');

-- Should now return rows without ORA-00932
SELECT * FROM CLOUDGUARD_APP.CG_REMEDIATED_WITH_REASON FETCH FIRST 5 ROWS ONLY;

CREATE OR REPLACE VIEW CLOUDGUARD_APP.CG_REMEDIATED_WITH_REASON AS
WITH rem AS (
  SELECT problem_id, MIN(event_time) AS remediated_time
  FROM   CLOUDGUARD_APP.CLOUDGUARD_FINDINGS
  WHERE  UPPER(event_type) = 'COM.ORACLECLOUD.CLOUDGUARD.PROBLEMREMEDIATED'
  GROUP  BY problem_id
),
det AS (
  SELECT problem_id, MIN(event_time) AS first_detected_time
  FROM   CLOUDGUARD_APP.CLOUDGUARD_FINDINGS
  WHERE  UPPER(event_type) = 'COM.ORACLECLOUD.CLOUDGUARD.PROBLEMDETECTED'
  GROUP  BY problem_id
)
SELECT
  r.problem_id,
  f.problem_name,
  d.first_detected_time,
  r.remediated_time,

  /* Prefer REASON; fallback PROBLEM_DESCRIPTION â€” normalize CLOBs to VARCHAR2 */
  COALESCE(
    NULLIF(TRIM(DBMS_LOB.SUBSTR(TO_CLOB(f.reason),              4000)), ''),
    NULLIF(TRIM(DBMS_LOB.SUBSTR(TO_CLOB(f.problem_description), 4000)), '')
  ) AS remediation_reason,

  /* ---- additionalDetails (parsed columns) ---- */
  JSON_VALUE(f.ADDITIONAL_DETAILS_JSON, '$.status'            RETURNING VARCHAR2(100))   AS addl_status,
  JSON_VALUE(f.ADDITIONAL_DETAILS_JSON, '$.riskLevel'         RETURNING VARCHAR2(100))   AS addl_risk_level,
  JSON_VALUE(f.ADDITIONAL_DETAILS_JSON, '$.problemType'       RETURNING VARCHAR2(200))   AS addl_problem_type,
  JSON_VALUE(f.ADDITIONAL_DETAILS_JSON, '$.problemName'       RETURNING VARCHAR2(400))   AS addl_problem_name,
  JSON_VALUE(f.ADDITIONAL_DETAILS_JSON, '$.resourceName'      RETURNING VARCHAR2(4000))  AS addl_resource_name,
  JSON_VALUE(f.ADDITIONAL_DETAILS_JSON, '$.resourceId'        RETURNING VARCHAR2(4000))  AS addl_resource_id,
  JSON_VALUE(f.ADDITIONAL_DETAILS_JSON, '$.resourceType'      RETURNING VARCHAR2(400))   AS addl_resource_type,
  JSON_VALUE(f.ADDITIONAL_DETAILS_JSON, '$.targetId'          RETURNING VARCHAR2(4000))  AS addl_target_id,
  JSON_VALUE(f.ADDITIONAL_DETAILS_JSON, '$.labels'            RETURNING VARCHAR2(4000))  AS addl_labels,
  JSON_VALUE(f.ADDITIONAL_DETAILS_JSON, '$.region'            RETURNING VARCHAR2(200))   AS addl_region,

  /* nested object: problemAdditionalDetails.comments */
  JSON_VALUE(f.ADDITIONAL_DETAILS_JSON, '$.problemAdditionalDetails.comments'
             RETURNING VARCHAR2(4000)) AS problem_additional_comments,

  /* Time-to-resolve (days) */
  CASE WHEN d.first_detected_time IS NOT NULL
       THEN ROUND(CAST(r.remediated_time AS DATE) - CAST(d.first_detected_time AS DATE), 4)
  END AS ttr_days

FROM rem r
JOIN CLOUDGUARD_APP.CLOUDGUARD_FINDINGS f
  ON f.problem_id = r.problem_id
 AND f.event_time = r.remediated_time
 AND UPPER(f.event_type) = 'COM.ORACLECLOUD.CLOUDGUARD.PROBLEMREMEDIATED'
LEFT JOIN det d
  ON d.problem_id = r.problem_id;

ORDER BY r.remediated_time DESC;
